#include "imports/stdlib.fc";
#include "imports/utils.fc";

const COMMITMENT_EXECTUION_FEE = 5000000;

int op::recipient_withdraw() asm "1 PUSHINT";

(slice, cell, cell, int, cell, int, cell) load_data() inline {
    var ds = get_data().begin_parse();
    return (
        ds~load_msg_addr(),
        ds~load_ref(),
        ds~load_ref(),
        ds~load_uint(32),
        ds~load_ref(),
        ds~load_uint(32),
        ds~load_ref()
    );
}


() save_data(cell awarded_key_list) impure inline {
    (
        slice staker_address,
        cell title,
        cell description,
        int due_date,
        cell recipients_key_list,
        int recipients_count,
        cell previous
    ) = load_data();

    set_data(begin_cell()
        .store_slice(staker_address)
        .store_ref(title)
        .store_ref(description)
        .store_uint(due_date, 32)
        .store_ref(recipients_key_list)
        .store_uint(recipients_count, 32)
        .store_ref(awarded_key_list)
        .end_cell());
}


(slice, cell, cell, int) get_info() method_id {
    (
        slice staker_address,
        cell title,
        cell description,
        int due_date,
        cell recipients_key_list,
        int recipients_count,
        cell awarded_key_list
    ) = load_data();

    return (
        staker_address,
        title,
        description,
        due_date
    );
}

int balance() method_id {
    var [balance, _] = get_balance();
    return balance;
}

() recv_internal(int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        ;; ignore empty messages
        return ();
    }


    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);

    if (flags & 1) {
        ;; ignore all bounced messages
        return ();
    }

    slice sender_address = cs~load_msg_addr();
    int op = in_msg_body~load_uint(32);

    (
        slice staker_address,
        cell title,
        cell description,
        int due_date,
        cell recipients_key_list,
        int recipients_count,
        cell awarded_key_list
    ) = load_data();

    if (op == op::recipient_withdraw()) {
        cell recipient_key_cell = in_msg_body~load_ref();
        slice recipient_key = recipient_key_cell.begin_parse();
        int recipient_key_hash = string_hash(recipient_key);

        int already_awarded = find_cell_tree_slice(awarded_key_list, recipient_key_hash);

        ;;todo add exit codes table
        throw_if(77, already_awarded == 1);

        int recipient_key_found = find_cell_tree_slice(recipients_key_list, recipient_key_hash);
        ;;todo add min max balance
        int award = balance() / recipients_count;

        ;;todo add exit codes table
        ;;todo add check if not awarded already
        ;;todo check due time
        ;;todo check status if completed - not get paid
        ;;todo check status if valid
        throw_if(76, recipient_key_found == -1);

        var msg = begin_cell()
            .store_uint(0x18, 6)
            .store_slice(sender_address)
            .store_coins(award - COMMITMENT_EXECTUION_FEE)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1);

        cell new_awarded_key_list = begin_cell()
            .store_ref(recipient_key_cell)
            .store_ref(awarded_key_list)
            .end_cell();

        save_data(new_awarded_key_list);

        send_raw_message(msg.end_cell(), 1);
    }
}

